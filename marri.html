<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Happy Married Life âœ¨ â€” Cracker Wishes</title>
  <style>
    :root{
      --bg-1: #030406;
      --bg-2: #0b0d10;
      --text: #ffd79a;
    }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{
      background: linear-gradient(180deg,var(--bg-1) 0%, var(--bg-2) 100%);
      color: #fff;
      overflow:hidden;
    }

    /* heading that matches your screenshot: centered near top, warm glow */
    .title{
      position:fixed;
      left:50%;
      top:56px;
      transform:translateX(-50%);
      z-index:40;
      font-size:48px;
      font-weight:700;
      letter-spacing:0.6px;
      color: var(--text);
      text-align:center;
      text-shadow:
        0 0 28px rgba(255,215,150,0.18),
        0 0 10px rgba(255,200,120,0.18),
        0 2px 0 rgba(0,0,0,0.35);
      display:flex;
      align-items:center;
      gap:10px;
      user-select:none;
      -webkit-user-select:none;
    }
    .title .emoji{
      font-size:42px;
      filter: drop-shadow(0 6px 8px rgba(0,0,0,0.5));
    }

    /* subtle hint (can be hidden if you want) */
    .hint{
      position:fixed;
      left:50%;
      bottom:20px;
      transform:translateX(-50%);
      z-index:40;
      font-weight:600;
      color:rgba(255,255,255,0.7);
      background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12));
      padding:8px 14px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.03);
    }

    /* full-screen canvas sits behind UI */
    canvas{
      position:fixed;
      inset:0;
      display:block;
      z-index:10;
    }

    /* small accessibility / clear button in top-left */
    .controls{
      position:fixed;
      left:16px;
      top:16px;
      z-index:45;
      display:flex;
      gap:8px;
    }
    .btn{
      background:rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.06);
      color:#fff;
      padding:8px 12px;
      border-radius:10px;
      font-weight:700;
      cursor:pointer;
      backdrop-filter: blur(4px);
    }
    @media (max-width:520px){
      .title{font-size:28px; top:34px}
      .title .emoji{font-size:28px}
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="title" aria-hidden="true">
    <span>Happy Married Life</span>
    <span class="emoji">âœ¨</span>
  </div>

  <div class="controls" aria-hidden="true">
    <button id="clearBtn" class="btn" title="Clear crackers">Clear</button>
    <button id="muteBtn" class="btn" title="Toggle sound">Sound</button>
  </div>

  <div class="hint">Tap or click anywhere to light crackers ðŸŽ†</div>

  <!-- optional audio: add your own file in src if you want -->
  <audio id="popSound" preload="auto">
    <!-- <source src="fireworks-chime.mp3" type="audio/mpeg"> -->
  </audio>

  <script>
  (function(){
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: true });
    let W = canvas.width = innerWidth;
    let H = canvas.height = innerHeight;
    const TAU = Math.PI * 2;
    const particles = [];
    const shells = [];
    const palettes = [
      ['#ffd166','#ff7b7b','#ffb3c1','#ffdf80'],
      ['#ffd6a5','#fdffb6','#caffbf','#9bf6ff'],
      ['#ffadad','#ffc6ff','#bde0fe','#a0c4ff'],
      ['#ff9f1c','#ffbf69','#f94144','#f8961e']
    ];

    function rand(min,max){ return Math.random() * (max - min) + min; }
    function resize(){ W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
    addEventListener('resize', resize);

    class Particle {
      constructor(x,y,dx,dy,color,size,life,glow){
        this.x = x; this.y = y; this.dx = dx; this.dy = dy;
        this.color = color; this.size = size; this.life = life; this.age = 0;
        this.glow = glow ?? rand(6,20);
      }
      step(dt){
        this.age += dt;
        this.x += this.dx * dt;
        this.y += this.dy * dt;
        this.dy += 0.0008 * dt; // gravity
        this.dx *= 0.999;
        this.dy *= 0.999;
      }
      alive(){ return this.age < this.life; }
      draw(ctx){
        const t = Math.max(0, 1 - this.age / this.life);
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.beginPath();
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = this.glow * t * 1.6;
        ctx.arc(this.x, this.y, Math.max(0.2, this.size * t), 0, TAU);
        ctx.fill();
        ctx.restore();
      }
    }

    // spawn rising shell (a cracker going up)
    function launchShell(tx, ty, palette){
      const sx = rand(20,60) > 40 ? rand(60, W-60) : tx; // some randomness
      const shell = {
        x: sx,
        y: H + 10,
        tx: ty,
        vx: (tx - sx) * 0.0006,
        vy: -rand(0.6,1.1) * rand(0.95,1.4),
        color: palette[Math.floor(rand(0,palette.length))],
        age: 0,
        duration: rand(600,1000)
      };
      shells.push(shell);
    }

    function explode(x,y,color,count=60,power=1){
      for(let i=0;i<count;i++){
        const a = rand(0,TAU);
        const s = Math.cos(rand(0,TAU)) * rand(0.9,1.6) * power * rand(2,6);
        const dx = Math.cos(a) * s;
        const dy = Math.sin(a) * s;
        const size = rand(1,3);
        const life = rand(900,1800);
        particles.push(new Particle(x,y,dx,dy,color,size,life));
      }
      // trailing embers
      for(let i=0;i<8;i++){
        particles.push(new Particle(x + rand(-12,12), y + rand(-12,12), rand(-0.3,0.3), rand(-0.3,0.3), color, rand(1.2,2.5), rand(1400,2400)));
      }
      // tiny sound pop if available
      try { if(window.playSound) window.playSound(); } catch(e){}
    }

    // small instant feedback explosion
    function smallPop(x,y){
      const palette = palettes[Math.floor(rand(0,palettes.length))];
      explode(x + rand(-16,16), y + rand(-16,16), palette[Math.floor(rand(0,palette.length))], Math.floor(rand(8,28)), 0.9);
    }

    // interactive burst: launches a couple shells toward y and some immediate pops
    function burstAt(x,y){
      const palette = palettes[Math.floor(rand(0,palettes.length))];
      const launches = Math.floor(rand(1,3));
      for(let i=0;i<launches;i++){
        launchShell(x + rand(-30,30), rand(Math.max(60, y - 40), Math.max(120, y + 20)), palette);
        if(Math.random() > 0.5) smallPop(x + rand(-24,24), y + rand(-24,24));
      }
    }

    // main animation
    let last = performance.now();
    function frame(now){
      const dt = now - last; last = now;
      // clear with slight fade for trails
      ctx.clearRect(0,0,W,H);

      // soft vignette/bkg glow (subtle)
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0,'rgba(255,220,180,0.02)');
      g.addColorStop(1,'rgba(0,0,0,0.18)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // update shells
      for(let i=shells.length-1;i>=0;i--){
        const s = shells[i];
        s.age += dt;
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        s.vy += 0.0009 * dt;
        // draw shell
        ctx.beginPath(); ctx.fillStyle = s.color; ctx.arc(s.x, s.y, 3.2, 0, TAU); ctx.fill();
        if(s.age > s.duration || s.y < 100){
          // explode into many particles
          explode(s.x, s.y, s.color, Math.floor(rand(36,120)), rand(0.8,1.8));
          shells.splice(i,1);
        }
      }

      // update particles
      for(let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        p.step(dt);
        if(!p.alive() || p.y > H + 80 || p.x < -60 || p.x > W + 60){ particles.splice(i,1); continue; }
        p.draw(ctx);
      }

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // input handlers (mouse + touch + pointer)
    function getPosFromEvent(e){
      if(e.touches && e.touches[0]){ return { x: e.touches[0].clientX, y: e.touches[0].clientY }; }
      return { x: e.clientX, y: e.clientY };
    }

    let pointerDown = false;
    canvas.addEventListener('pointerdown', (e)=>{
      pointerDown = true;
      const p = getPosFromEvent(e);
      burstAt(p.x, p.y);
    }, {passive:true});
    canvas.addEventListener('pointermove', (e)=>{
      if(!pointerDown) return;
      const p = getPosFromEvent(e);
      burstAt(p.x, p.y);
    }, {passive:true});
    window.addEventListener('pointerup', ()=>{ pointerDown = false; });

    // touch fallback
    canvas.addEventListener('touchstart', (e)=>{ const p = getPosFromEvent(e); burstAt(p.x,p.y); }, {passive:true});
    canvas.addEventListener('touchmove', (e)=>{ const p = getPosFromEvent(e); burstAt(p.x,p.y); }, {passive:true});

    // keyboard quick trigger
    addEventListener('keydown', (e)=>{ if(e.code === 'Space') burstAt(W/2, H/2); });

    // UI buttons
    document.getElementById('clearBtn').addEventListener('click', ()=>{
      particles.length = 0; shells.length = 0;
      ctx.clearRect(0,0,W,H);
    });

    // sound control (optional): user can drop an mp3 name into audio tag, or leave silent
    const popSound = document.getElementById('popSound');
    let soundOn = false;
    document.getElementById('muteBtn').addEventListener('click', ()=>{
      soundOn = !soundOn;
      document.getElementById('muteBtn').textContent = soundOn ? 'Sound On' : 'Sound';
      // create a small click sound fallback if no source provided (Web Audio)
      if(soundOn && !popSound.querySelector('source')){
        // create a short synth-like pop using WebAudio
        try {
          const ctxA = new (window.AudioContext || window.webkitAudioContext)();
          window.playSound = function(){
            if(!soundOn) return;
            const o = ctxA.createOscillator();
            const g = ctxA.createGain();
            o.type = 'square';
            o.frequency.setValueAtTime(800, ctxA.currentTime);
            g.gain.setValueAtTime(0.0001, ctxA.currentTime);
            g.gain.exponentialRampToValueAtTime(0.25, ctxA.currentTime + 0.005);
            g.gain.exponentialRampToValueAtTime(0.001, ctxA.currentTime + 0.2);
            o.connect(g); g.connect(ctxA.destination);
            o.start();
            o.stop(ctxA.currentTime + 0.16);
          };
        } catch(e){}
      } else if(!soundOn){
        window.playSound = function(){};
      }
    });

    // friendly initial bursts to welcome page view
    setTimeout(()=>{
      for(let i=0;i<5;i++){
        launchShell(rand(80, W-80), rand(H*0.15, H*0.45), palettes[Math.floor(rand(0,palettes.length))]);
      }
    }, 400);

  })();
  </script>
</body>
</html>
